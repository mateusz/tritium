#!/usr/bin/env python3
import os
import ast
import importlib.util
from pathlib import Path
from sorted_deps import ClassDependencyAnalyzer

def load_class_content(file_path, class_name):
    """Extract a class definition from a file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            code = f.read()
        
        tree = ast.parse(code)
        
        # Find the class definition
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef) and node.name == class_name:
                # Get the source code for the class
                class_source = ast.get_source_segment(code, node)
                if class_source:
                    return class_source
        
        return None
    except Exception as e:
        print(f"Error extracting class {class_name} from {file_path}: {e}")
        return None

def get_imports(file_path):
    """Extract all import statements from a file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            code = f.read()
        
        tree = ast.parse(code)
        
        imports = []
        for node in ast.walk(tree):
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                import_source = ast.get_source_segment(code, node)
                if import_source:
                    imports.append(import_source)
        
        return imports
    except Exception as e:
        print(f"Error extracting imports from {file_path}: {e}")
        return []

def is_local_import(import_stmt, class_names):
    """Determine if an import statement is referencing one of our bundled classes."""
    try:
        tree = ast.parse(import_stmt)
        for node in ast.walk(tree):
            if isinstance(node, ast.ImportFrom):
                # Check if importing from a module that matches a bundled class
                # This is a simplification - for a complete solution, we'd need to 
                # map module names to actual file paths
                for name in class_names:
                    if name.lower() in node.module.lower():
                        return True
                
                # Check if importing specific classes that we're bundling
                for alias in node.names:
                    if alias.name in class_names:
                        return True
            
            elif isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name in class_names:
                        return True
        
        return False
    except Exception as e:
        print(f"Error checking if import is local: {e}")
        return False

def main():
    # Create analyzer and find all classes
    analyzer = ClassDependencyAnalyzer()
    analyzer.find_all_classes()
    
    # Get classes sorted by dependencies
    sorted_classes = analyzer.get_sorted_classes()
    
    # Dictionary to track processed files and their imports
    processed_files = set()
    all_imports = set()
    
    # Open output file
    with open('tritium_bundle.py', 'w', encoding='utf-8') as outfile:
        # Add header
        outfile.write("#!/usr/bin/env python3\n")
        outfile.write("# This file was automatically generated by bundle_code.py\n\n")
        
        # Process each class
        for class_name in sorted_classes:
            file_path = analyzer.class_to_file.get(class_name)
            if not file_path:
                continue
            
            # Get imports from file if we haven't processed it yet
            if file_path not in processed_files:
                imports = get_imports(file_path)
                for imp in imports:
                    all_imports.add(imp)
                processed_files.add(file_path)
            
            # Extract class content
            class_content = load_class_content(file_path, class_name)
            if class_content:
                outfile.write(f"\n# From {file_path}\n")
                outfile.write(class_content)
                outfile.write("\n\n")
        
        # Filter out local imports
        filtered_imports = []
        for imp in sorted(all_imports):
            if not is_local_import(imp, sorted_classes):
                filtered_imports.append(imp)
        
        imports_text = "\n".join(filtered_imports)
        
        # Add imports to the top of the file
        with open('tritium_bundle.py', 'r', encoding='utf-8') as f:
            content = f.read()
        
        with open('tritium_bundle.py', 'w', encoding='utf-8') as f:
            header_lines = content.split('\n\n', 1)[0]
            f.write(f"{header_lines}\n\n# External Imports Only\n{imports_text}\n\n")
            f.write(content.split('\n\n', 1)[1])
    
    print(f"Bundle complete! Classes bundled to tritium_bundle.py")

if __name__ == "__main__":
    main()
